'use strict';
module.exports = (function() {
    var path = require('path')
    var child_process = require('child_process');
    var util = require('util');
    var EventEmitter = require('events').EventEmitter;
    var net = require('net');

    //////////////// JSONRPC 2.0
    var jsonrpc_events = function(rpc) {
        this.rpc = rpc;
    }

    // Inherit event emitter functionality
    util.inherits(jsonrpc_events, EventEmitter);

    jsonrpc_events.prototype.result = function(fn) {
        this.on("result", fn);
        return this;
    }

    jsonrpc_events.prototype.error = function(fn) {
        this.on("error", fn);
        return this;
    }

    var jsonrpc = function(transport, namespace) {
        this.msg_id = 0;
        this.namespace = namespace?namespace+".":"";
        this.msg_events = {}
        this.transport = transport;
        var base = this;
        this.buffer = "";

        this.transport.on("data", function(data_in) {

        try {
            data_in = data_in.toString();
            for( var i=0; i < data_in.length; i++) {
                var char = data_in[i];

                if (char == "\n") {
                    var data = "";
                    try {
                        var data = JSON.parse(base.buffer.toString());
                        //console.log("ON DATA: ", data)
                    } catch(e) {
                        base.emit("error", base.buffer.toString())
                        console.log("PARSING ERROR", e, base.buffer.toString())
                    }
                    base.buffer = ""
                    var msg_evt = null;
                    if (data["id"] !== undefined) {
                        msg_evt = base.msg_events["e"+data["id"]];
                    }
                    if (msg_evt != null) {
                        if (data["result"] !== undefined) {
                            msg_evt.emit("result", data["result"]);
                        } else if (data["error"] !== undefined) {
                            msg_evt.emit("error", data["error"]);
                        } else {
                            base.emit("error", {"error": "UNHANDLED", "data": data});
                        }
                        delete base.msg_events["e"+data["id"]];
                    } else if ('method' in data) { //wrap this in try and emit error
                        try {
                           var parts = data['method'].split('.');
                           if ( parts[0] != '@' ) {
                              for(var i=0, len = parts.length, obj = window; i < len; ++i) {
                                 obj = obj[parts[i]];
                              }
                              var result = obj.apply(this, data['params']);
                              base.result(result, data['id']);
                           } else {
                              //console.log("EMIT", parts[1], base, data['params']);
                              base.emit("emit", parts[1], data['params']);
                           }
                        }
                        catch (e) {
                           console.log("ERROR DATA: ", data)
                           console.log(e); //kk to remove
                           base.error(e, data['id']);
                        }
                    } else {
                        if (data["error"] !== undefined) {
                            base.emit("error", data['error']);
                        }
                    }
                } else {
                    base.buffer += char;
                }
            }
        }
        catch (e) {
            console.log("TRANSPORT ERROR", e, base.buffer.toString())
            base.emit("error", base.buffer.toString());
        }
        });
        this.transport.on("error", function(data) {
            console.log("On transport error", data.toString());
            base.emit("error", data);
        });
        this.transport.on("close", function(code) {
            base.emit("disconnected", base, code);
        });
        this.transport.on("open", function(transport) {
            base.emit("connected", base);
        });
    };

    // Inherit event emitter functionality
    util.inherits(jsonrpc, EventEmitter);

    jsonrpc.prototype.call = function(method, params, on_result, on_error) {
        this.msg_id++;
        var data = JSON.stringify({
            "jsonrpc":"2.0",
            "method": this.namespace+method,
            "params": params,
            "id": this.msg_id
        }) + "\n";
        //console.log("CALL:", data);
        var evt = new jsonrpc_events(this)
        this.msg_events["e"+this.msg_id] = evt;
        this.transport.send(data);
        return evt;
    }

    jsonrpc.prototype.result = function(result, id) {
        var data = JSON.stringify({
            "jsonrpc":"2.0",
            "result": result,
            "id": id
        }) + "\n";
        this.transport.send(data);
    }

    jsonrpc.prototype.error = function(error, id) {
        var data = JSON.stringify({
            "jsonrpc":"2.0",
            "error": error,
            "id": id
        }) + "\n";
        this.transport.send(data);
    }

    ////////// TCP Transport Lib
    var SocketTransport = function(address, type, options) {
        this.address = address;
        this.type = type;
        this.options = options;
        EventEmitter.call(this);
    }

    util.inherits(SocketTransport, EventEmitter);

    SocketTransport.prototype.send = function(data) {
        this.sock.write(data);
    }

    SocketTransport.prototype.start = function() {
        this.sock = new net.Socket();
        var base = this;

        if ( this.type == 'TCP' ) {
           this.TCPConnect(this.address.ip, this.address.port);
        } else if ( this.type == "UNIX" ) {
           this.UnixConnect(this.address)
        }

        this.sock.on('data', function(data) {
            base.emit('data', data);
        });

        this.sock.on('close', function() {
            base.emit('close');
        });

        this.sock.on('error', function(error) {
            base.emit('error', error);
        });
    }

    SocketTransport.prototype.TCPConnect = function(ip, port) {
      var base = this;
      this.sock.connect(port, ip, function() {
         base.emit('open', base);
      });
    }

    SocketTransport.prototype.UnixConnect = function(address) {
      var base = this;
      this.sock.connect(address, function() {
         base.emit('open', base);
      });
    }

    var TCPIOLib = function(ip, port, options) {
        TCPIOLib.super_.call(this, {ip:ip, port:port}, 'TCP', options);
    }
    util.inherits(TCPIOLib, SocketTransport)

    var UnixIOLib = function(address, options) {
        UnixIOLib.super_.call(this, address, 'UNIX', options);
    }
    util.inherits(UnixIOLib, SocketTransport)

    ////////// STDIO Transport Lib
    var stdioLib = function(bin_path, args, options) {
        this.bin_path = path.resolve(bin_path);
        this.bin_args = args;
        this.bin_options = options;
        EventEmitter.call(this);
    };

    // Inherit event emitter functionality
    util.inherits(stdioLib, EventEmitter);

    stdioLib.prototype.send = function(data) {
        this.child.stdin.write(data);
    }

    stdioLib.prototype.kill = function(n) {
        this.child.kill(n)
    }

    stdioLib.prototype.start = function() {
        this.child = child_process.spawn(this.bin_path, this.bin_args, this.bin_options);
        this.started = true;
        var base = this;

        this.child.stdout.on('data', function(data) {
            /*if (global.debug)
               console.log("child:stdout", data.toString()); */
            base.emit("data", data);
        });
        this.child.stderr.on('data', function(data) {
            /*if (global.debug)
               console.log("child:stderr", data.toString()); */
            base.emit("error", data);
        });
        this.child.stdout.on('exit', function(code) {
            //console.log("stdout:exit", code);
            base.emit("close", code);
        });
        this.child.on('close', function(code) {
            //console.log("child:close", code)
            base.emit("close", code);
        });
        this.child.on('disconnect', function(code) {
            //console.log("child:disconnect", code)
        });
        this.emit("open", this);
    };

    return {
        stdioLib: stdioLib,
        jsonrpc: jsonrpc,
        SocketTransport: SocketTransport,
        TCPIOLib: TCPIOLib,
        UnixIOLib: UnixIOLib
    };
}());
